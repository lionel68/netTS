---
title: "R Notebook"
output: html_notebook
---
### Calcul du nb de permutation necessaire
## Select a window of 60 days: Pick a behaviour and a troop
#library
```{r}
library(sna)
library(igraph)
library(plotrix)
library(asnipe)
library(tnet)
library(plyr)
library(dplyr)
library(ggplot2)
```


```{r}
# Upload & subset data
Global.data <- read.csv ("Data2015-2017.csv")
Global.data$TimeStamp <- paste(Global.data$Date,Global.data$Time)

#Select RST
RST.all<- subset(Global.data,Troop == "RST")
RST.adult<- subset (RST.all, ismomID == "TRUE")
RST.AF <- subset (RST.adult, SexID == "F")

# Select proximity activity
SRSTl.RST<- subset (RST.AF, Activity %in% c ("Resting", "Nursing", "Allo-mother", "Allo-groomer", "Allo-receiver", "Foraging"))
# Select proximity behaviour (posture dependent)
SpRST <- SRSTl.RST[!(SRSTl.RST$Posture=="Locomote"),]
Spatial.RST2 <- SpRST[!(SpRST$Posture=="Stand"),]
Spatial.RST3 <- Spatial.RST2[!(Spatial.RST2$NearestF=="0"),]
Spatial.RST4 <- Spatial.RST3[!(Spatial.RST3$NearestF=="na"),]
Spatial.RST5 <- Spatial.RST4[!(Spatial.RST4$NearestF=="af"),]

# Put 5m threshold for Distance
Spatial.RST6<- Spatial.RST5[!(Spatial.RST5$DistanceF=="10"),]
Spatial.RST7<- Spatial.RST6[!(Spatial.RST6$DistanceF=="15"),]
Spatial.RST8<- Spatial.RST7[!(Spatial.RST7$DistanceF=="20"),]
Spatial.RST9<- Spatial.RST8[!(Spatial.RST8$DistanceF=="None Observable"),]
Spatial.RST10<- Spatial.RST9[!(Spatial.RST9$DistanceF=="NA"),]
Spatial.RST11<- Spatial.RST10[!(Spatial.RST10$DistanceF=="20+"),]

# Get nearestF 
Sp.RST.female <- dplyr::select(Spatial.RST11, Date=TimeStamp, DayNb= Nb_Day, from=ID, to = NearestF, Distance = DistanceF, Activity= Activity, DeathID=DeathID, DeathPartner=DeathPartner, DeathNearestF=DeathNearestF, NewID=NewAdultID, NewPartner=NewAdultPArtner, NewNearestF=NewAdultNearestF, Week=Week)

## Load nb.scan file neeeded to control for sampling effort
Scan.nb<-read.csv("Nb.scan.per.troop.csv")
RST.scan<- Scan.nb[,c("Day","number.scan.RST")]

```


## Function: create network + permutation

```{r}
##Network

# First create the network function 
create.a.network<-function(elist){
  
  gg <- graph_from_data_frame (elist, directed = TRUE, vertices = NULL) 
  
  return (gg) # what comes out after using the function
}

#Then create the edgelist function needed in the network function
create.an.edgeList<-function(edge.list){
  
  edge.list.NN<-dplyr::count(edge.list, from , to)
  
  return(edge.list.NN)
}
```


## Weekly permutation code

TB: i've checked this block. We just forgot to reset the windowdata with the new permuted data so it was always using the original data... where one permutation wouldn't change the values by much. This should work now?!? 

Also i broke the function in 2, it's always easier to figure out smaller functional bits than large ones.

```{r}
#takes a dataframe with to and from columns and performs a permutation
permute.directed.associations <- function(df.start){
  
  #Check for selfe loops
  no.loops= FALSE
  
  #choose to or from association to permute
  if(0.5 > runif(1)){
    
    while(no.loops == FALSE){
      
      #choose two individuals to switch
      rows.to.switch <- sample(1:nrow(df.start),2,F)
      
      #record old order
      old.order <- df.start$to
      new.order <- df.start$to
      
      #update order
      new.order[rows.to.switch[1]] <- old.order[rows.to.switch[2]]
      new.order[rows.to.switch[2]] <- old.order[rows.to.switch[1]]
      
      #check to make sure there are no self loops
      if(sum(as.character(df.start$from)==as.character(new.order) )==0){
        
        df.start$to <-  as.character(new.order)
        df.j.perm<- df.start
        no.loops=TRUE
        
      }
    }
  }  else{
    while(no.loops == FALSE){
      
      #choose two individuals to switch
      rows.to.switch <- sample(1:nrow(df.start),2,F)
      
      #record old order
      old.order <- df.start$from
      new.order <- df.start$from
      
      #update order
      new.order[rows.to.switch[1]] <- old.order[rows.to.switch[2]]
      new.order[rows.to.switch[2]] <- old.order[rows.to.switch[1]]
      
      #check to make sure there are no self loops
      if(sum(as.character(new.order)==as.character(df.start$to) )==0){
        
        df.start$from <- as.character(new.order)
        df.j.perm<- df.start
        no.loops=TRUE
        
      }
    }
  }
  
  return(df.j.perm)
  
}


#runs permutations within set time periods (e.g., weeks)
weekly.perm <- function(windowdata, nPerm=1000){
  
  #vector to store the measures
  Perm.CC <- vector()
  
  #get the number of time periods  
  time.periods<- unique(windowdata$Week)
  
  #one permutation per time period
  for(i in 1:nPerm){
    
    #select time period randomly
    time.period.sample <- sample(time.periods, 1)
    
    #create data subsets: with the time period and without
    df.j.without   <- windowdata[windowdata$Week!=time.period.sample,]
    df.j.with      <- windowdata[windowdata$Week==time.period.sample,]
    
    #permute the data within the time period
    df.j.with.perm <- permute.directed.associations(df.j.with)
    
    #bind the permuted data with the unpermuted data
    df.all.perm<-rbind(df.j.without,df.j.with.perm)
    
    #Create edgelist
    Edgelist<- create.an.edgeList(df.all.perm)
    
    #Create graph in order to get the measure 
    Perm.network <- create.a.network(Edgelist)
    
    # Get measure
    Perm.CC[length(Perm.CC)+1]<- mean(igraph::closeness(Perm.network, mode=c("total"), weights=1/(E(Perm.network)$weight)))
    
    #reset window data to have the permuted values
    windowdata <- df.all.perm
  }
  
  return(quantile(Perm.CC, probs = c(0.0275,0.975), na.rm=T))
  
}



```


## Get the final format of dataset thnaks to network function

```{r}
#count up occurances between all the dyads
elist<-dplyr::count(Sp.RST.female, from , to)

#remove na values for creation of the network
elist <- elist[complete.cases(elist),]

#create the network
names(elist)<- c("from", "to", "weight")
```


## Moving window + permutation

```{r}
# Set up window's parameters
windowsize <- 180
windowStart  <-2
max<- max(Sp.RST.female$DayNb)
max<-1094
# Minimum nb of interactions needed
threshold <- 20

# Vectors needed to store values
Day<-vector()
Closeness<- vector()
Perm.CC<- vector ()
Perm.Upper.Values<-vector()
Perm.Lower.Values<-vector()

while (windowStart + windowsize<=max) {
  
  
  # Fill vectors with NA so that if the threshold isn't met, NA are already written down
  CC<-rep(NA,1)
  Perm.Upper.CI <-rep(NA,1)
  Perm.Lower.CI <- rep(NA,1)
  
  #Create sample
  windowdata <-Sp.RST.female[which((Sp.RST.female$DayNb >= windowStart) & (Sp.RST.female$DayNb <= (windowStart + windowsize - 1))),] 
  
  # set up a threshold that needs to be met so that we can calculate our metric, otherwise we put NA
  if(nrow(windowdata)>threshold){
    
    ## from empirical data
    #Create an edgelist from data
    Edgelist<-create.an.edgeList(windowdata)
    
    # Isolate nb of scan for right nb of day
    nb.scan<- subset(RST.scan, Day >= windowStart & Day <=windowStart + windowsize)
    scan.tot<- as.numeric(sum(nb.scan$number.scan.RST))
    Edgelist$n<- (Edgelist$n)/scan.tot
    names(Edgelist)<- c("from", "to", "weight")
    
    #Create the social network
    Window.Network <- create.a.network(Edgelist) 
    
    #calculate the network measure calculated
    CC<-mean(igraph::closeness(Window.Network, weights = 1/(E(Window.Network)$weight), mode=c("total")))
    
    #run the permutation
    Perm.CC <- weekly.perm(windowdata , 3000)
    
    #Store values
    Perm.Upper.CI<- Perm.CC[2]
    Perm.Lower.CI<- Perm.CC[1]
  } 
  
  #store day so we know what value corresponds to what day
  Day[length(Day)+1]<-windowStart
  
  # Store observed values
  Closeness [length(Closeness)+1] <- CC
  
  # Store permutation values
  Perm.Upper.Values [length(Perm.Upper.Values)+1]<- Perm.Upper.CI
  Perm.Lower.Values [length(Perm.Lower.Values)+1]<- Perm.Lower.CI
  
  # Shift window
  windowStart<- windowStart+10
}
# Create dataframe
OutcomeRST <- data.frame(obs=Closeness, lower.perm=Perm.Lower.Values, upper.perm=Perm.Upper.Values, Day=Day)

```



```{r}
# Plot
ggplot(OutcomeRST, aes(x=Day, y=obs))  + geom_ribbon(aes(ymin=lower.perm, ymax=upper.perm), fill="red") + geom_point(color="blue") + labs(x= "2015 to 2017 with a 180 days windowsize - shift +1", y="Closeness in spatial proximity behaviour on RST")
```

