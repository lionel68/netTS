---
title: "R Notebook"
output: html_notebook
---
### Calcul du nb de permutation necessaire
## Select a window of 60 days: Pick a behaviour and a troop
#library
```{r}
library(sna)
library(igraph)
library(plotrix)
library(asnipe)
library(tnet)
library(plyr)
library(dplyr)
library(ggplot2)
```


```{r}
# Upload & subset data
Global.data <- read.csv ("Data2015-2017.csv")
Global.data$TimeStamp <- paste(Global.data$Date,Global.data$Time)

#Select RST
RST.all<- subset(Global.data,Troop == "RST")
RST.adult<- subset (RST.all, ismomID == "TRUE")
RST.AF <- subset (RST.adult, SexID == "F")

# Select proximity activity
SRSTl.RST<- subset (RST.AF, Activity %in% c ("Resting", "Nursing", "Allo-mother", "Allo-groomer", "Allo-receiver", "Foraging"))
# Select proximity behaviour (posture dependent)
SpRST <- SRSTl.RST[!(SRSTl.RST$Posture=="Locomote"),]
Spatial.RST2 <- SpRST[!(SpRST$Posture=="Stand"),]
Spatial.RST3 <- Spatial.RST2[!(Spatial.RST2$NearestF=="0"),]
Spatial.RST4 <- Spatial.RST3[!(Spatial.RST3$NearestF=="na"),]
Spatial.RST5 <- Spatial.RST4[!(Spatial.RST4$NearestF=="af"),]

# Put 5m threshold for Distance
Spatial.RST6<- Spatial.RST5[!(Spatial.RST5$DistanceF=="10"),]
Spatial.RST7<- Spatial.RST6[!(Spatial.RST6$DistanceF=="15"),]
Spatial.RST8<- Spatial.RST7[!(Spatial.RST7$DistanceF=="20"),]
Spatial.RST9<- Spatial.RST8[!(Spatial.RST8$DistanceF=="None Observable"),]
Spatial.RST10<- Spatial.RST9[!(Spatial.RST9$DistanceF=="NA"),]
Spatial.RST11<- Spatial.RST10[!(Spatial.RST10$DistanceF=="20+"),]

# Get nearestF 
Sp.RST.female <- dplyr::select(Spatial.RST11, Date=TimeStamp, DayNb= Nb_Day, from=ID, to = NearestF, Distance = DistanceF, Activity= Activity, DeathID=DeathID, DeathPartner=DeathPartner, DeathNearestF=DeathNearestF, NewID=NewAdultID, NewPartner=NewAdultPArtner, NewNearestF=NewAdultNearestF, Week=Week)

## Load nb.scan file neeeded to control for sampling effort
Scan.nb<-read.csv("Nb.scan.per.troop.csv")
RST.scan<- Scan.nb[,c("Day","number.scan.RST")]

```


## Function: create network + permutation

```{r}
##Network

# First create the network function 
create.a.network<-function(elist){
  
  gg <- graph_from_data_frame (elist, directed = TRUE, vertices = NULL) 
  
  return (gg) # what comes out after using the function
}

#Then create the edgelist function needed in the network function
create.an.edgeList<-function(edge.list){
  
  edge.list.NN<-dplyr::count(edge.list, from , to)
  
  return(edge.list.NN)
}
```


## Weekly permutation code
##git 

```{r}
weekly.perm <- function(windowdata, nPerm=1000){
  
  net.list <- list(create.a.network(windowdata))
  
    week.unique<- unique(windowdata$Week)
    
    for(i in 1:nPerm){
      df<-NULL
      #data<- matrix(,ncol=13)
      #Net.Perm.Frame = as.data.frame(data)
      #colnames(Net.Perm.Frame) <- colnames(df.window)
      for (j in 1:length(week.unique)){ 
        df.j <- windowdata[windowdata$Week==week.unique[j],]
        no.loops= FALSE
        
        #choose to or from grooming to permute
        if(0.5 > runif(1)){
          
          while(no.loops == FALSE){
            
            #choose two individuals to switch
            rows.to.switch <- sample(1:nrow(df.j),2,F)
            
            #record old order
            old.order <- df.j$to
            new.order <- df.j$to
            
            #update order
            new.order[rows.to.switch[1]] <- old.order[rows.to.switch[2]]
            new.order[rows.to.switch[2]] <- old.order[rows.to.switch[1]]
            
            #check to make sure there are no self loops
            if(sum(as.character(df.j$from)==as.character(new.order) )==0){
              
              df.j$to <- new.order
              df.j.perm<- df.j
              no.loops=TRUE
              
            }
          }
        }  else{
          while(no.loops == FALSE){
            
            #choose two individuals to switch
            rows.to.switch <- sample(1:nrow(df.j),2,F)
            
            #record old order
            old.order <- df.j$from
            new.order <- df.j$from
            
            #update order
            new.order[rows.to.switch[1]] <- old.order[rows.to.switch[2]]
            new.order[rows.to.switch[2]] <- old.order[rows.to.switch[1]]
            
            #check to make sure there are no self loops
            if(sum(as.character(new.order)==as.character(df.j$to) )==0){
              
              df.j$from <- new.order
              df.j.perm<- df.j
              no.loops=TRUE
              
            }
          }
        }
        df<-rbind(df,df.j.perm)
      }
       #Create edgelist
    Edgelist<- create.an.edgeList(df)
    #Create graph in order to get the measure 
    Perm.network <- create.a.network(Edgelist)
    
    # Get measure
    Perm.CC[length(Perm.CC)+1]<- mean(igraph::closeness(Perm.network, mode=c("total"), weights=1/(E(Perm.network)$weight)))
    }
     
    return(quantile(Perm.CC, probs = c(0.0275,0.975), na.rm=T))

  }



```


## Get the final format of dataset thnaks to network function

```{r}
#count up occurances between all the dyads
elist<-dplyr::count(Sp.RST.female, from , to)

#remove na values for creation of the network
elist <- elist[complete.cases(elist),]

#create the network
names(elist)<- c("from", "to", "weight")
```


## Moving window + permutation

```{r}
# Set up window's parameters
windowsize <- 180
windowStart  <-2
max<- max(Sp.RST.female$DayNb)
max<-1094
# Minimum nb of interactions needed
threshold <- 20

# Vectors needed to store values
  Day<-vector()
  Closeness<- vector()
  Perm.CC<- vector ()
  Perm.Upper.Values<-vector()
  Perm.Lower.Values<-vector()

while (windowStart + windowsize<=max) {
  
  
  # Fill vectors with NA so that if the threshold isn't met, NA are already written down
  CC<-rep(NA,1)
  Perm.Upper.CI <-rep(NA,1)
  Perm.Lower.CI <- rep(NA,1)
  
  #Create sample
  windowdata <-Sp.RST.female[which((Sp.RST.female$DayNb >= windowStart) & (Sp.RST.female$DayNb <= (windowStart + windowsize - 1))),] 
  
  # set up a threshold that needs to be met so that we can calculate our metric, otherwise we put NA
  if(nrow(windowdata)>threshold){
    
    ## from empirical data
    #Create an edgelist from data
    Edgelist<-create.an.edgeList(windowdata)
    
    # Isolate nb of scan for right nb of day
    nb.scan<- subset(RST.scan, Day >= windowStart & Day <=windowStart + windowsize)
    scan.tot<- as.numeric(sum(nb.scan$number.scan.RST))
    Edgelist$n<- (Edgelist$n)/scan.tot
    names(Edgelist)<- c("from", "to", "weight")
    
    #Create the social network
    Window.Network <- create.a.network(Edgelist) 
    
    #calculate the network measure calculated
    CC<-mean(igraph::closeness(Window.Network, weights = 1/(E(Window.Network)$weight), mode=c("total")))
    
    #run the permutation
    Perm.CC <- weekly.perm(windowdata , 30)
    
    #Store values
    Perm.Upper.CI<- Perm.CC[2]
    Perm.Lower.CI<- Perm.CC[1]
  } 
  
  #store day so we know what value corresponds to what day
  Day[length(Day)+1]<-windowStart
  
  # Store observed values
  Closeness [length(Closeness)+1] <- CC
  
  # Store permutation values
  Perm.Upper.Values [length(Perm.Upper.Values)+1]<- Perm.Upper.CI
  Perm.Lower.Values [length(Perm.Lower.Values)+1]<- Perm.Lower.CI
  
  # Shift window
  windowStart<- windowStart+10
}
# Create dataframe
OutcomeRST <- data.frame(obs=Closeness, lower.perm=Perm.Lower.Values, upper.perm=Perm.Upper.Values, Day=Day)

```



```{r}
# Plot
ggplot(OutcomeRST, aes(x=Day, y=obs))  + geom_ribbon(aes(ymin=lower.perm, ymax=upper.perm), fill="red") + geom_point(color="blue") + labs(x= "2015 to 2017 with a 180 days windowsize - shift +1", y="Closeness in spatial proximity behaviour on RST")
```

