---
title: "Measuring network similarity over time"
author: "Tyler R. Bonnell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Measuring network similarity over time}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


##Introduction

  When looking at a social network in time, it is often important to ask how stable or similar is the network? This vignette runs through the use of the cosine similarity measure proposed by Newman (2010), using the netTS package.
  
  The vignette is organised as follows:
  * 1. Graph level similarity
  * 2. Node level similarity
  * 3. Application to real data

###Libraries
```{r, warning=FALSE,message=FALSE}
#devtools::install_github("tbonne/netTS")
library(ggplot2)
library(netTS)
library(igraph)
library(plyr)
library(dplyr)
library(reshape2)
```


###1. Graph level similarity

Simulate a random graph and create a list of modified graphs
```{r}
#create a random graph
graph.original <- igraph::erdos.renyi.game(15,0.3)

#simulate change to the original graph
graph.list <- list(graph.original)
graph.temp <- graph.original
for(i in 1:6){
  
  #remove and add an edge
  graph.modified <- graph.temp %>% delete.edges(sample(E(graph.temp),1)) 
  graph.modified <- graph.modified %>% add.edges(edges=c(sample(V(graph.modified),2))) 
  graph.modified <- simplify(graph.modified)
  
  #record change
  graph.list[[length(graph.list)+1]] <- graph.modified
  graph.temp <- graph.modified
}

par(mfrow=c(2,3))
for(i in 1:6){
  plot(graph.list[[i]], main=paste0("Network ",i))
}
```

Measure similarity over time
```{r}
similarity.from.start <- vector()

for(i in 1:6){
  similarity.from.start[length(similarity.from.start)+1] <- cosine_between_graphs(graph.list[[1]],graph.list[[i]])
similarity.between.events <- vector()
}

plot(similarity.from.start, type="b", col="red", main="Network similarity", ylab = "Cosine similarity")
```


###1. Node level similarity

Using the same simulated data from above we now look at how similarity at the node level changes in time.


Measure similarity over time for nodes
```{r}
#measure similarity at the node level
similarity.from.start <- data.frame((cosine_between_graphs_nodes(graph.list[[1]],graph.list[[1]])))
names(similarity.from.start) <- colnames(cosine_between_graphs_nodes(graph.list[[1]],graph.list[[1]]))
for(i in 2:6){
  similarity.from.start <- rbind.fill( similarity.from.start,  as.data.frame(cosine_between_graphs_nodes(graph.list[[1]],graph.list[[i]]))  )
}

#take a look at the similarity measures as a table
similarity.from.start #Note: NaN values here indicate when a node has no edges in at least one graph being compared.

#plot the similarity of nodes over time
similarity.from.start$seq <- seq(1,6,by=1)
df.melt<-melt(similarity.from.start, id.vars="seq")
names(df.melt)[2] <- "node"
ggplot(df.melt, aes(y=value, x= seq, color=node)) + geom_line() + theme_classic()

```


```{r}
graph1 <- graph.list[[1]]
graph2 <- graph.list[[1]]
  
cos.test <- cosine_between_graphs_nodes<- function(graph1, graph2, directed=FALSE, mode="out"){

  node.cosine <- vector()

  #create weighted edge list from first graph
  g1.edges<-as.data.frame(get.edgelist(graph1, names=TRUE))
  if(is.null(igraph::E(graph1)$weight)){
    g1.edges$weight <- rep(1,nrow(g1.edges))
  } else {
    g1.edges$weight<-igraph::E(graph1)$weight
  }
  g1.edges$joinC <- ifelse(as.character(g1.edges$V1) < as.character(g1.edges$V2), paste(g1.edges$V1, g1.edges$V2), paste(g1.edges$V2, g1.edges$V1))

  #create weighted edge list from second graph
  g2.edges<-as.data.frame(get.edgelist(graph2, names=TRUE))
  if(is.null(igraph::E(graph2)$weight)){
    g2.edges$weight <- rep(1,nrow(g2.edges))
  } else {
    g2.edges$weight<-igraph::E(graph2)$weight
  }
  g2.edges$joinC <- ifelse(as.character(g2.edges$V1) < as.character(g2.edges$V2), paste(g2.edges$V1, g2.edges$V2), paste(g2.edges$V2, g2.edges$V1))

  #join the weighted edge lists, setting NAs equal to 0
  comb<-full_join(g1.edges,g2.edges,by="joinC")
  comb$weight.x[is.na(comb$weight.x)]<-0
  comb$weight.y[is.na(comb$weight.y)]<-0

  names.unique<-unique(c(comb$V1.x,comb$V2.x))
  names.unique <- names.unique[is.na(names.unique)==FALSE]

  if(directed==FALSE){

    for(i in 1:(length(names.unique))){
      temp.node.w <- dplyr::filter(comb, V1.x==names.unique[i] | V2.x==names.unique[i])
      node.cosine[length(node.cosine)+1]<-lsa::cosine(temp.node.w$weight.x,temp.node.w$weight.y)
    }

  } else if (directed==TRUE){

    if(mode=="out"){
      for(i in 1:(length(names.unique))){
        temp.node.w <- dplyr::filter(comb, V1.x==names.unique[i])
        node.cosine[length(node.cosine)+1]<-lsa::cosine(temp.node.w$weight.x,temp.node.w$weight.y)
      }
    }

    if(mode=="in"){
      for(i in 1:(length(names.unique))){
        temp.node.w <- dplyr::filter(comb, V2.x==names.unique[i])
        node.cosine[length(node.cosine)+1]<-lsa::cosine(temp.node.w$weight.x,temp.node.w$weight.y)
      }
    }

    if(mode=="total"){
      for(i in 1:(length(names.unique))){
        temp.node.w <- dplyr::filter(comb, V1.x==names.unique[i] | V2.x==names.unique[i])
        node.cosine[length(node.cosine)+1]<-lsa::cosine(temp.node.w$weight.x,temp.node.w$weight.y)
      }
    }


  }

  #node.cosine[is.nan(node.cosine)]<-0
  cos.df<-as.data.frame(t(node.cosine))
  names(cos.df)<-names.unique

  return(cos.df)

}
```



###1. Application to a real dataset: baboon proximity network

```{r}
library(lubridate)
library(plyr)
min(mdy(netTS::groomEvents$` date`))

#extract cosine measures at the graph level
graph.cosine <- graphTS(event.data = groomEvents, windowSize = 30, windowShift = 10, type= "cosine")

#extract cosine measures at the node level
node.cosine <- nodeTS(event.data = groomEvents, windowSize = 30, windowShift = 10, type= "cosine")

#plot the cosine similarities
df.node.cosine <- melt(node.cosine, id.vars = c("windowStart","windowEnd", "windowStartDate", "windowEndDate", "nEvents" ))
names(df.node.cosine)[names(df.node.cosine)=="variable"] <- "node"
ggplot(df.node.cosine, aes(x=windowStart, y=value, color=node)) + geom_line() + geom_line(data=graph.cosine, aes(x=windowStart, y=cosine), size=2, col="black") + labs(y="Cosine similarity", x = "Day") + theme_classic()
```


## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
